import sys
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
sys.path.append('/Users/joshuaneronha/Documents/Brown/Research/LeakyWaveML/ml_model/binary')
sys.path.append('/Users/joshuaneronha/Documents/Brown/Research/LeakyWaveML')
import pickle
import tensorflow as tf
from statsmodels.stats.weightstats import ztest
mpl.rcParams['font.family'] = 'Arial'
plt.rcParams['font.size'] = 12
plt.rcParams['axes.linewidth'] = 2
from tensorflow import losses

from preprocess import import_data, import_val_data

floquet = list(np.array([  6.,  16.,  24.,  29.,  32.,  34.,  49.,  60.,  62.,  63.,  66.,
        69.,  71.,  73.,  77.,  81.,  84.,  86.,  89.,  90.,  95., 100.,
       101., 104., 106., 110., 114., 118., 120., 123., 126., 129., 131.,
       132., 147.]).astype('int'))

### Generating the box plots with all data...

slots, peaks, _ = import_data()

fig, axs = plt.subplots(1,1,tight_layout=True,figsize=(6,4))

boxplot = axs.boxplot(peaks, sym = '', patch_artist = True)
plt.xticks(np.arange(0,36,5),np.arange(0,36,5))
plt.xlabel('Peak Count')
plt.ylabel('Amplitude (normalized)')
plt.ylim([-0.4,1])

# plt.savefig('paper/figures/boxbinarymono.svg')

### Analyzing testing data that we put back through COMSOL...

with open('analysis/binary/test_data510.pkl','rb') as file:
    test_data = pickle.load(file)
    peaks, true, pred, waves = test_data

val510_slots, val510_peaks, val510_waves = import_val_data('analysis/binary/validation510')

#compute two MSEs -- one between the objective signal and the signal generated by the model generated slot, and a mse_list_control
#(i.e. two random slots, which is why there is i+1... acts as an offset)

mse_list_binary = []
mse_list_control = []

for i in np.arange(500):
    mse_b = losses.mse(waves[i][0:181], val510_waves[i][0:181])
    mse_list_binary.append(mse_b)

    try:
        mse_c = losses.mse(waves[i+1][0:181], val510_waves[i][0:181])
        mse_list_control.append(mse_c)
    except:
        pass



def top_16(slot):
    '''
    take the 16 slots most likely to be scattering
    '''
    median = np.sort(slot)[18]
    out = [1 if x >= median else 0 for x in slot]
    return out

predrounded = np.array(pred)
for i in np.arange(len(pred)):
    predrounded[i,:] = top_16(predrounded[i,:])

#compute test statistics

ba = tf.keras.metrics.BinaryAccuracy()
ba(true,pred)
ztest(mse_list_binary, mse_list_control,value=0,alternative='two-sided')
np.mean(mse_list_binary)
np.mean(mse_list_control)

#MSE histogram

fig, axs = plt.subplots(1,1,tight_layout=True,figsize=(5.5,4))

N, bins, patches = axs.hist(tf.stack(mse_list_binary).numpy(),bins=15,ec='black',color='#7fcdbb', label='_nolegend_')

for i,thispatch in enumerate(patches):
    thispatch.set_alpha(0.75)

axs.set_xlabel('Mean Square Error')
axs.set_ylabel('Count')

N, bins, patches = axs.hist(tf.stack(mse_list_control).numpy(),bins=bins,ec='black',color='#1d91c0', label='_nolegend_')

for i,thispatch in enumerate(patches):
    thispatch.set_alpha(0.5)

axs.legend(['Model','Random'])

def plot_instance_beta(val):
    '''
    Function to plot model examples
    '''
    fig, ax = plt.subplots(1,4,gridspec_kw={'width_ratios': [1, 1, 1, 10]},figsize=(7,4))
    ax[0].imshow(tf.expand_dims(true[val],1),cmap='YlGnBu')
    ax[0].axes.xaxis.set_visible(False)
    ax[0].axes.yaxis.set_visible(False)
    ax[1].imshow(tf.expand_dims(pred[val],1),cmap='YlGnBu')
    ax[1].axes.xaxis.set_visible(False)
    ax[1].axes.yaxis.set_visible(False)
    forcmap = ax[2].imshow(tf.expand_dims(top_16(pred[val]),1),cmap='YlGnBu')
    ax[2].axes.xaxis.set_visible(False)
    ax[2].axes.yaxis.set_visible(False)# cax = ax[3].inset_axes([1.04, 0.2, 0.05, 0.6], transform=ax[3].transAxes)
    ax[3].plot(waves[val][0:181],color='#0c2c84')
    ax[3].plot(val510_waves[val][0:181],color='#7fcdbb')

    print('MSE binary = ' + str(losses.mse(waves[val][0:181],val510_waves[val][0:181])))

plot_instance_beta(477)
#we use examples 477 and 108 in the paper

# plt.savefig('paper/figures/477.eps')
